class IRule(ABC):
    @abstractmethod
    def check(self, neighbor):
        pass
        
class Rule(IRule):
    def __init__(self, start, end, positivity, values):
        self.start = start
        self.end = end
        self.positivity = positivity
        self.values = values

    def check(self, neighbor):
        for key,values in self.values.items():
            if self.positivity:
                if neighbor.neighbors[key] not in values:
                    return -1
            else:
                if neighbor.neighbors[key] in values:
                    return -1
        return self.end
                

class Rules:
    def __init__(self):
        self.rules = []

    def add(self, rule):
        self.rules.append(rule)

    def check(self, state, neighbor):
        for rule in self.rules:
            if rule.start != state:
                continue
            res = rule.check(neighbor)
            if res != -1:
                return res
        return state
